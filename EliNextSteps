Eli Launcher Reliability Blueprint
==================================

## Objective
- **Mission**: Guarantee that every launcher execution pulls the latest code, builds cleanly, and starts all components without errors.
- **Scope**: `Launch-All-New.bat`, `Test-Launchers.bat`, any shared PowerShell helpers, desktop binaries under `clients/`, and all artifacts logged in `launcher-logs/`.

## Phase 1 – Source freshness and repository guardrails
- **Automate git sync**: Prepend `git fetch --all` + `git rebase origin/main` (or active release branch) inside `Launch-All-New.bat`; abort if conflicts or untracked files remain (`git status --porcelain`).
- **Submodule / package alignment**: Run `git submodule sync --recursive` and `git submodule update --init --recursive` plus `dotnet restore` (or relevant package restore) before any build; capture output to `launcher-logs/master-launcher.log`.
- **Commit provenance display**: Embed the short commit hash and timestamp into the launcher splash screen or console banner so operators can verify they are on the latest bits.

## Phase 2 – Build reproducibility & environment hygiene
- **Clean builds by default**: Force `dotnet clean` + `dotnet build --configuration Release` for every solution the launcher touches; mirror the exact pipeline in `Test-Launchers.bat`.
- **Purge stale artifacts**: Delete `bin/`, `obj/`, installer caches, and temporary deployment folders before rebuilding to prevent stale DLL reuse.
- **Runtime prerequisites check**: Validate required runtimes (e.g., .NET Desktop Runtime, VC++ redistributables) and critical environment variables; emit warnings and exit non-zero if anything is missing.

## Phase 3 – Launcher script modernization
- **Centralize shared logic**: Extract common steps into `scripts/launcher-prereqs.ps1`; have both BAT files call the PowerShell script, keeping each wrapper as a thin entry point.
- **Configuration verification**: Compare `appsettings.*`, `Secrets.config`, and other critical configs against checksum or schema templates; block launch on mismatches and provide remediation hints.
- **Deployment staging**: Copy freshly built binaries to staging folders only after a successful build; use atomic swaps (rename temp to live) to avoid partial updates.

## Phase 4 – Pre-launch verification & automated tests
- **Integrated test battery**: Run `dotnet test` for critical projects, WPF UI smoke tests, and any integration harness before starting services; store TRX/JUnit outputs in `launcher-logs/tests/`.
- **Static analysis & linting**: Optionally invoke analyzers (StyleCop, Roslyn, ESLint for web assets) to catch regressions before launch; treat new errors as blockers.
- **Manual review checkpoints**: Provide a concise checklist for operators (latest commit hash, clean git status, tests succeeded) and require acknowledgment before proceeding.

## Phase 5 – Runtime smoke checks & rollback safety
- **Health probe cycle**: Start each service in diagnostic mode, verify health endpoints or ping checks, and fail fast if any component logs errors or refuses to bind.
- **Port/process collision detection**: Scan for conflicting listeners with PowerShell `Get-NetTCPConnection` before launching services; surface actionable guidance if a port is occupied.
- **Rollback switch**: Maintain a fallback set of last-known-good binaries and expose a `--rollback` flag that swaps to the prior build when smoke checks fail.

## Phase 6 – Observability, logging, and zero-error policy
- **Structured logs**: Normalize launcher logs to JSON or consistent text with timestamps, commit hash, and component tags; ensure `launcher-logs/master-launcher.log` captures every stage.
- **Alert thresholds**: Define acceptable warning/error counts per run. Exceeding the budget should abort the launch and notify responsible engineers (e.g., via Teams webhook).
- **Telemetry export**: Forward launcher metrics (duration, success state, failure stage) to a dashboard (Azure Monitor, Grafana) for trend analysis.

## Phase 7 – Documentation & ownership
- **README refresh**: Update `LAUNCHER-README.md` with the new automated workflow, guardrails, log locations, and troubleshooting paths.
- **Change ownership**: Assign primary/secondary owners for launcher maintenance; record escalation contacts inside the README and within the scripts.
- **Continuous improvement cadence**: Schedule quarterly retrospectives to review failed launches, update scripts, and add new automated checks as the product evolves.
